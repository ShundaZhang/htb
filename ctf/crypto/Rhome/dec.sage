'''
base^x == value
x = discrete_log(value, base)

p = 2*q*r + 1
g = h^(2*r)%p
this will cause more than 1 root can satisify the condition g^a mod p == A, which means a small `a` will als work (the a we caculate is not the real rand self.a)!
'''
from Crypto.Util.number import isPrime, long_to_bytes, getPrime
from Crypto.Cipher import AES
from hashlib import sha256

p = 53125270761463893814615879663110545668875934538776154044001666893980782825370377371236270512190417139524818942645456164141169555862922797059344264072894298747632927007
g = 10651768523045822653277227478099013961827298269917275036387328416276676793077034598722238346405808729772127591176979591693399682519455579237924083174580184142634249110
A = 15859994480938537797978652794755167393691253371000771427440079000333258617232121651973321385429447626656589607194903627218439700896449242278307363128630511125440940828
B = 47623987820302651160567976222779743115762385234315238653501717315927713025830421803349556780268910009757661279958359510752725594655760765042278054390200176218390838691


Zp = Zmod(p)
gp = Zp(g)
gc = Zp(B)
#b = discrete_log(gc, gp)
#print(b)

b = 3185641346453
ss = int(pow(A, b, p))

encrypted = bytes.fromhex('30ca0870f2c2b2e297ac064b45c25524b08492edcfa66eebad00f7328dba4dee')

key = sha256(long_to_bytes(ss)).digest()[:16]
cipher = AES.new(key, AES.MODE_ECB)
flag = cipher.decrypt(encrypted)
print(flag)
#HTB{00ps_wh4t_4_sm411_0rd3r}
