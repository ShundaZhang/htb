

# This file was *autogenerated* from the file dec.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_7 = Integer(7); _sage_const_16 = Integer(16)
import sys
import csv
import json
import challenge

DEBUG=True
def dbg(line, force=False, end='\n'):
    if DEBUG or force:
        print(line, flush=True, file=sys.stderr, end=end)
        pass
    pass

def prnt(line, force=False):
    dbg(line, force=force)
    print(line, flush=True)
    pass

def inp(lines=_sage_const_1 , chars=_sage_const_0 , force=False):
    line = ''
    for _ in range(lines):
        line = input()
        dbg(line, force=force)
    if chars > _sage_const_0 :
        dbg(sys.stdin.read(chars), force=force, end='')
    return line

def hash_msg(msg, n):
    from hashlib import sha1
    h = sha1(msg).digest()
    h = int.from_bytes(h, 'big')
    h = bin(h)[_sage_const_2 :]
    h = int(h[:len(bin(n)[_sage_const_2 :])], _sage_const_2 )
    return h

def inverse(x, n):
    return int(pow(x, -_sage_const_1 , n))

def ppow(x, e, n):
    return int(pow(x, e, n))

def sign(dsa, msg):
    from random import randint
    h = hash_msg(msg, dsa.n)
    k = randint(_sage_const_1 , dsa.n-_sage_const_1 )
    r = pow(dsa.g, k, dsa.n)
    s = (pow(k, -_sage_const_1 , dsa.n) * (h + dsa.key * r)) % dsa.n
    lsb = k % (_sage_const_2  ** _sage_const_7 )
    return {"h": hex(h)[_sage_const_2 :], "r": hex(r)[_sage_const_2 :], "s": hex(s)[_sage_const_2 :], "lsb": bin(lsb)[_sage_const_2 :] }

def verify_h(dsa, h, r, s):
    c = inverse(s, dsa.n)
    k = (c * (h + dsa.key * r)) % dsa.n
    return r == pow(dsa.g, k, dsa.n)

def verify_m(dsa, m, r, s):
    h = hash_msg(m, dsa.n)
    return verify_h(dsa, h, r, s)


if __name__ == '__main__':
    dsa = challenge.ECDSA()
    msg = b'william;yarmouth;22-11-2021;09:00'
    sig_r = _sage_const_1 
    sig_s = _sage_const_0 
    known_bits = _sage_const_7 

    mm = list()
    hrsa = list()
    # Read provided information
    with open('appointments.txt', 'r') as csvf:
        csvr = csv.reader(csvf)
        header = next(csvr)
        for row in csvr:
            mm.append(row[_sage_const_0 ].encode('utf8'))
            pass
        pass
    with open('signatures.txt', 'r') as csvf:
        csvr = csv.reader(csvf, delimiter=';')
        header = next(csvr)
        for h, r, s, a in csvr:
            hrsa.append( (int(h,_sage_const_16 ), int(r,_sage_const_16 ), int(s,_sage_const_16 ), int(a,_sage_const_2 )) )
            pass
        pass
    
    # Compute coeffs
    bigB = _sage_const_2 **(len(bin(dsa.n)[_sage_const_2 :]) - known_bits + _sage_const_1 ) # Upper bound for all bi
    AA = list()
    BB = list()
    Fn = GF(dsa.n)
    h0, r0, s0, a0 = [Fn(x) for x in hrsa[_sage_const_0 ]]
    for i, (hi, ri, si, ai) in enumerate(hrsa):
        if i == _sage_const_0 :
            continue
        hi, ri, si, ai = Fn(hi), Fn(ri), Fn(si), Fn(ai)
        Ai = ri * si**-_sage_const_1  * r0**-_sage_const_1  * s0
        Bi = -_sage_const_1  * Fn(_sage_const_2 )**-known_bits * (ai - si**-_sage_const_1  * (hi + r0**-_sage_const_1  * ri * (s0 * a0 - h0)))
        AA.append(Ai.lift())
        BB.append(Bi.lift())
        pass
    dbg(f"[+] Computed {len(AA)} coefficients.\n[+] Constructing lattice...")

    # Construct lattice
    size = len(AA)
    MM = Matrix(ZZ, size + _sage_const_2 )
    for ii in range(size):
        MM[ii, ii] = dsa.n
        MM[-_sage_const_2 , ii] = AA[ii]
        MM[-_sage_const_1 , ii] = BB[ii]
        pass
    MM[-_sage_const_2 ,-_sage_const_2 ] = _sage_const_1 
    MM[-_sage_const_1 ,-_sage_const_1 ] = bigB

    # Perform LLL
    dbg("[+] Performing base reduction...")
    MB = MM.LLL()                 # LLL sorts the basis vectors by size
    if Fn(MB[_sage_const_0 , -_sage_const_1 ]) == Fn(bigB): # so we only check the first basis vector
        k0 = Fn(_sage_const_2 )**known_bits * MB[_sage_const_0 , -_sage_const_2 ] + a0
        dsa.key = ((s0 * k0 - h0) * r0**-_sage_const_1 ).lift()
        dbg('[+] Key candidate found!')
        pass
    else:
        dbg('[!] No candidate found :(')
        sys.exit()
    
    # Verify a signature to know that the key candidate is correct
    m1 = mm[_sage_const_1 ]
    _, r1, s1, a1 = hrsa[_sage_const_1 ]
    if verify_m(dsa, m1, r1, s1):
        wohoo = True
        dbg(f'[+] Candidate verifies correctly!')
        pass
    else:
        dbg("[!] Key candidate was not the key :(")
        sys.exit()

    # Craft signature for message
    dbg(f"[+] Crafting signature...")
    dic = sign(dsa, msg)

    # Print flag
    dbg(f"[+] Getting flag...\n")
    msg2server = json.dumps({'pt': msg.decode('ascii'), 'r': dic['r'], 's': dic['s']})
    
    prnt(msg2server)
    
    #inp(3, 2)
    #prnt(msg2server)
    #try:
    #    inp(2)
    #    pass
    #except:
    #    pass
    #pass

