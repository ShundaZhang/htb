

# This file was *autogenerated* from the file dec.sage
from sage.all_cmdline import *   # import sage library

_sage_const_30347 = Integer(30347); _sage_const_2 = Integer(2); _sage_const_256 = Integer(256); _sage_const_255 = Integer(255); _sage_const_91720173941422125335466921700213991383508377854521057423162397714341988797837 = Integer(91720173941422125335466921700213991383508377854521057423162397714341988797837); _sage_const_2222 = Integer(2222); _sage_const_63833675802420156398805369963806732759142071085691800691701958621949852525123 = Integer(63833675802420156398805369963806732759142071085691800691701958621949852525123); _sage_const_34254234730885990686440742326036159677494676758891281923083444140485355483921 = Integer(34254234730885990686440742326036159677494676758891281923083444140485355483921); _sage_const_70957363256125413168019046277930201321562073571727581661927923802585513554191 = Integer(70957363256125413168019046277930201321562073571727581661927923802585513554191); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 = Integer(6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039); _sage_const_0 = Integer(0)#https://chovid99.github.io/posts/cyber-apocalypse-2023-crypto/#converging-visions
#https://github.com/jvdsn/crypto-attacks/blob/master/attacks/ecc/smart_attack.py

from pwn import *

context.log_level = 'debug'

ip, port = '68.183.37.122', _sage_const_30347 
io = remote(ip, port)

high = _sage_const_2 **_sage_const_256 
low = _sage_const_2 **_sage_const_255 

'''
while high - low >= 0:
	print(f'high, low = {high, low}')
	print(f'diff = {high - low}')
	if high - low == 0 :
		break
	mid = (high + low)//2
	io.sendlineafter(b'> ', b'1')
	io.sendlineafter(b'x: ', str(mid).encode())
	out = io.recvline()
	if b'greater' in out:
		high = mid
	else:
		low = mid + 1
p = high

print(f'recovered p = {p}')
'''
#91720173941422125335466921700213991383508377854521057423162397714341988797837

p = _sage_const_91720173941422125335466921700213991383508377854521057423162397714341988797837 

x1, y1 = _sage_const_2222 , _sage_const_63833675802420156398805369963806732759142071085691800691701958621949852525123 
x2, y2 = _sage_const_34254234730885990686440742326036159677494676758891281923083444140485355483921 , _sage_const_70957363256125413168019046277930201321562073571727581661927923802585513554191 

a = (y1**_sage_const_2  - y2**_sage_const_2  - x1**_sage_const_3  + x2**_sage_const_3 )*pow(x1-x2, -_sage_const_1 , p)%p
b = (y1**_sage_const_2  - x1**_sage_const_3  - a*x1)%p

E = EllipticCurve(GF(p), [a, b])
print(f'E.order() = {E.order()}')
print(f'p = {p}')

# Lifts a point to the p-adic numbers.
def _lift(E, P, gf):
	x, y = map(ZZ, P.xy())
	for point_ in E.lift_x(x, all=True):
		_, y_ = map(gf, point_.xy())
		if y == y_:
			return point_


def attack(G, P):
	"""
	Solves the discrete logarithm problem using Smart's attack.
	More information: Smart N. P., "The discrete logarithm problem on elliptic curves of trace one"
	:param G: the base point
	:param P: the point multiplication result
	:return: l such that l * G == P
	"""
	E = G.curve()
	gf = E.base_ring()
	p = gf.order()
	assert E.trace_of_frobenius() == _sage_const_1 , f"Curve should have trace of Frobenius = 1."

	E = EllipticCurve(Qp(p), [int(a) + p * ZZ.random_element(_sage_const_1 , p) for a in E.a_invariants()])
	G = p * _lift(E, G, gf)
	P = p * _lift(E, P, gf)
	Gx, Gy = G.xy()
	Px, Py = P.xy()
	return int(gf((Px / Py) / (Gx / Gy)))

def setup_point(x):
	io.sendlineafter(b'> ', b'1')
	io.sendlineafter(b'x: ', str(x).encode())
	_, x1, y1 = eval(io.recvline().strip())
	return x1, y1

def next_point():
	io.sendlineafter(b'> ', b'2')
	io.recvline()
	_, x, y = eval(io.recvline().strip())
	return x, y

x1, y1 = setup_point(x1)
x2, y2 = next_point()

G = E(x1, y1)
P = E(x2, y2)
enc_seed = attack(G, P)

m = p * _sage_const_6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 
#m is too big, we just try p
print(f'recovered enc_seed: {enc_seed}') # enc_seed = seed^2 mod p

inc = int.from_bytes(b"Coordinates lost in space", "big")

Z = IntegerModRing(p)
seeds_1 = Z(enc_seed).nth_root(_sage_const_2 , all=True) # There will be two roots

next_seed = (a * pow(seeds_1[_sage_const_1 ], _sage_const_3 ) + b * seeds_1[_sage_const_1 ] + inc)%p
setup_point(x1)

prediction_point = G*int(next_seed)
print(f'prediction: {prediction_point}')
io.sendlineafter(b'> ', b'3')
io.sendlineafter(b'x: ', str(prediction_point[_sage_const_0 ]).encode())
io.sendlineafter(b'y: ', str(prediction_point[_sage_const_1 ]).encode())
print(io.recvall())

